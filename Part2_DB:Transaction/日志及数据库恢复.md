## 基于日志的回滚（13.5）
-----
### 基本日志
&emsp;基本日志的主要内容包括：
  - 事务标识符T -> 执行写操作事务的唯一标识符
  - 数据项标识符X -> 操作对象(被修改的数据项)的唯一标识符
  - 前像V1 -> 更新前数据的值
  - 后像V2 -> 更新后数据的值

&emsp;基本的日志记录形式
  - <T Start>表示事务T已经开始
  - <T Commit>表示事务T已经提交
  - <T Abort>表示事务不能成功完成，已终止
  - <T,X,V1,V2>表示事务T对数据项X执行写操作，写之前的旧值为V1，写之后的新值为V2

#### 不同的执行对应的恢复策略
&emsp;在执行更新事务的时候，根据后像写入磁盘的时间不同，有对应3种方案进行回滚
**(1) 后像在事务提交后才写入磁盘**
|步骤|动作|日志|
|:---:|:---:|:----:|
|1||<T1,Start>|
|2|Read(A)||
|3|A:=A+A*0.1||
|4|Write(A)|<T1,A,,22>|
|5|Read(B)||
|6|B:B-B*0.05||
|7|Write(B)|<T1,b,,28.5>|
|8||<T1,Commit>|
|9|A写入磁盘||
|10|B写入磁盘||

在这种情况下，使用日志进行回滚的步骤为：
1.从后向前扫描日志，将提交的事务放在redo-list队列中
2.从日志文件开始处扫描，对遇到的每个<T,X,,V>

```swift
if T in redo-list{
  X = V
}else{
  logFile.nextLog()
}
```

3.对于未完成的事务，在日志中写入一个<T,Abort>并刷新日志  

**(2) 后像在事务提交之前完全写入磁盘**
|步骤|动作|日志|
|:---:|:---:|:----:|
|1||<T1,Start>|
|2|Read(A)||
|3|A:=A+A*0.1||
|4|Write(A)|<T1,A,,22>|
|5|Read(B)||
|6|B:B-B*0.05||
|7|Write(B)|<T1,b,,28.5>|
|8|A写入磁盘||
|9|B写入磁盘||
|10||<T1,Commit>|

在这种情况下，使用日志进行回滚的步骤为：
1.从后向前扫描日志，将提交的事务放在redo-list队列中
2.从日志文件开始处扫描，对遇到的每个<T,X,,V>

```swift
if T !in redo-list{
  X = V
}else{
  logFile.nextLog()
}
```

**(3) 后像在事务提交前后写入磁盘**
|步骤|动作|日志|
|:---:|:---:|:----:|
|1||<T1,Start>|
|2|Read(A)||
|3|A:=A+A*0.1||
|4|Write(A)|<T1,A,,22>|
|5|Read(B)||
|6|B:B-B*0.05||
|7|Write(B)|<T1,b,,28.5>|
|8|A写入磁盘||
|9||<T1,Commit>|
|10|B写入磁盘||

在这种情况下，使用日志进行回滚的步骤为：

```swift
if T.commited {
  redo(T) //更新事务所有数据项
}else{
  undo(T) //将事务所有数据项设置为前像
}
```

### WAL
-----
&emsp;**预写日志的原理**：修改并不直接写入到数据库文件中，而是写入到另外一个称为WAL的文件中；如果事务失败，WAL中的记录会被忽略，撤销修改；如果事务成功，它将在随后的某个时间被写回到数据库文件中，提交修改。

&emsp;读时，在WAL文件中搜索，找到最后一个写入点，记住它，并忽略在此之后的写入点（这保证了读写和读读可以并行执行）；随后，它确定所要读的数据所在页是否在WAL文件中，如果在，则读WAL文件中的数据，如果不在，则直接读数据库文件中的数据。
&emsp;写时，写入到WAL文件中即可，但是必须保证独占写入，因此写写之间不能并行执行。

- 优点
  - 1.读和写可以完全地并发执行，不会互相阻塞（但是写之间仍然不能并发）。 
  - 2.WAL在大多数情况下，拥有更好的性能（因为无需每次写入时都要写两个文件，减少磁盘I/O）。
  - 3.磁盘I/O行为更容易被预测。

- 缺点
  - 当写入数据很大或者事务很长的时候，数据库性能将下降。因为这将导致WAL文件长时间被占用，并且WAL文件的大小将会很大，增加寻址时间。

## 检查点
&emsp;利用日志进行数据库恢复的时候，通常需要探索整个日志才能确定哪些事务需要redo，那些需要undo，这样会导致：
- 搜索整个日志消耗大量时间
- 许多需要redo的事务的更新操作已经写入磁盘，redo将浪费大量时间

检查点技术让系统不定期的简历检查点，保存数据库的状态，当需要恢复扫描日志文件时候只用到达<CheckPoint>就能停止。创建检查点的3中方法有：
- 提交一致性检查点
- 高速缓存一致性检查点
- 模糊一致性检查点

**提交一致性检查点**建立时候需要等待所有活动事务全部提交，在等待过程中新的事务不能开始，这将导致系统的阻塞。
**高速缓存一致性检查点**建立时候不用等待活动事务提交，只需要保证事务不执行更新操作就可建立，提高恢复过程的效率。
**模糊一致检查点**去除高速缓存一致性检查点建立时候事务暂停的限制，允许事务在checkpoint---缓存写入磁盘之间更新。磁盘上需要维护一个last-chackpoint信息，当缓冲区的数据刷盘完成时候才会更新，以此应对系统在checkpoint---缓存写入磁盘之间崩溃。

## Snapshot
快照是数据库在某一时间点的视图，快照并不复制整个数据库的页，而是仅仅复制在快照建立时间点之后改变的页。

> 数据库取数据库的原理是这样的：快照生成之后，如果数据库中任何数据页都没有被修改（insert,delete,update等），这个时候快照的mdf文件是空的，几乎不占用任何磁盘空间，这个时候从数据库快照中取数据库其实还是从源数据库中取。快照生成之后，数据库中的数据发生变动，这个时候数据库快照的mdf文件中就有了数据，但是只限于刚刚被修改之前的数据。
> 举例 ： 10 被修改为 100，这个时候数据库快照中存放10，源数据库中存放100.如果从数据库快照中去的数据既有被修改的也有没有被修改的，修改部分从数据库快照的mdf文件中获得，没有被修改的还是从源数据库中获得。

## 介质故障
RAID（磁盘阵列技术）将一组磁盘驱动器使用逻辑的方式连接起来，对上层用户透明，作为逻辑上的一个磁盘驱动器使用。RAID通过冗余技术，提供一个高级别的数据保护措施。
优点：
  - 成本低，功耗小，传输速率高
  - 可以提供容错能力
  - 具有数据校验能力

&emsp;介质故障的恢复使用备份将数据恢复到一个一致性状态，再使用redo将数据尽可能的恢复。